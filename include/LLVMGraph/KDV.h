/**
 *
 * @brief     This class is used to determine sizes of arguments to pre-
 *            determined "kernel functions". We refer to this as Kernel Volume
 *            Data, or KDV for short.
 *
 * In order to generate size informations for arguments of a kernel function,
 * multiple steps need to be performed:
 *
 *     1. Identify the kernels, which are annotated in source code (future
 *        versions may also support configuration files)
 *
 *     2. For each kernel get the call that is made to it
 *
 *     3. For each call, extract its arguments and analyze their types. The size
 *        of each type is summed up and is further multiplied with the amount of
 *        allocations.
 *
 *     4. A call to a helper function is placed prior the call to the kernel
 *        function. The helper function returns the estimated KDV.
 *
 */

#ifndef KERNEL_VOLUME_H
#define KERNEL_VOLUME_H

#include <llvm/Module.h>

#include <LLVMGraph/TypeGraph.h>
#include <LLVMGraph/KDV/ArgParser.h>
#include <LLVMGraph/KDV/TypeHandlers/BaseTypeHandler.h>
#include <LLVMGraph/DataDirection.h>

#include <llvm/Analysis/AliasAnalysis.h>

#include <map>
#include <set>
/*
struct MallocInfo {
	llvm::Function *mallocF;
	std::vector<llvm::Value*> mallocArgs;
};
*/
class KernelVolume {
private:
    llvm::AliasAnalysis *AA;

	/**
	 *
	 * This variable holds the set of identified kernel functions which shall be
	 * analyzed by the "Call Processor"
	 *
	 */
	std::set<llvm::Function*> KernelFunctions;

	/**
	 *
	 * The Argument-to-Size-Function (ASF) Map. It assigns two Size-Functions to
	 * a single argument. The first size function calculates the size of the
	 * argument itself. The second size function is used if the argument is a
	 * pointer and thus a call to "malloc" or "new" may be used.
	 *
	 */
	std::map<llvm::Value*, std::pair<llvm::Function*, bool>> ASF_Map;

	/**
	 * This holds the current LLVM module.
	 */
    llvm::Module *M;

    /**
     * This variable holds the top-most instance of type handlers which is used
     * to analyze types with several modules.
     */
    BaseTypeHandler *BTH;

    /**
     * This holds a pointer to an instance of the Argument Parser, which creates
     * the Type Graph (TG).
     */
    ArgParser *parser;
    
    /**
     * This is the current Type Graph (TG) generated by the Argument Parser.
     */
    TG *g;

public:
    /**
     *
     * The constructor, which gets the current LLVM module as well as a pointer
     * to the (empty) graph that shall be used.
     *
     */
	KernelVolume(llvm::Module *_M, TG *_g, AliasAnalysis *_AA) {
		g = _g; M = _M;
		parser = NULL;
		BTH = NULL;
		AA = _AA;
	}

	/**
	 * This is the main entry point for the Kernel Data Volume library. It may
	 * be used by any "higher" class to run KDV analysis.
	 *
	 */
	void run();

	/**
	 * The "Call Processor" takes a kernel function and then it performs three
	 * separate steps:
	 *
	 *     1. It searches all calls to the function
	 *     2. For each call the arguments are processed and their sizes are
	 *        evaluated.
	 *     3. A call to the KDV helper function is placed prior the call to
	 *        the kernel function
	 *
	 */
    void callProcessor(llvm::Module *M,
    		           llvm::Function *kernelF,
    		           llvm::Function *printF);

    /**
     * This function is responsible for extracting all kernel functions that are
     * annotated in the source code.
     *
     */
	void getKernelsFromGlobalAnnotations(llvm::GlobalValue *gv);

};

#endif /* KERNEL_VOLUME_H */
